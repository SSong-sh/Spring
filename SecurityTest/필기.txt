
Spring Security
- 인증, 허가
- 동작 방식 > 서블릿 필터와 스프링 인터셉터를 사용해서 처리


1. 기본 설정
- MyBatis(HikariCP)
- Log4j2
- JUnit


2. 테스트
- src/test/java > com.test.security > MapperTest.java
- com.test.security.mapper > TestMapper.java(I)


2. Spring Security Dependency 추가
- 4개


3. security-context.xml
- /webapp/WEB-INF/spring/security-context.xml
- root-context.xml, servlet-context.xml 동일한 설정 파일
- 기존 컨텍스트와 분리해서 구성 추천
- New > Spring Bean configuration File


4. Security Filter 등록
- web.xml
- 스프링 시큐리티가 스프링 MVC에서 동작할 수 있도록..


5. 실행
- 프로젝트 > Run as > Run on Server
- 에러 발생 > No bean named 'springSecurityFilterChain' available
- 해결 > web.xml > contextConfigLocation >/WEB-INF/spring/security-context.xml 등록


- security-context.xml 기본 구문 작성
<security:http>
	<security:form-login/>
</security:http>

<security:authentication-manager>

</security:authentication-manager>

<에러나면 이거 뒤에 숫자 버전 지우기>
xsi:schemaLocation="http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-5.0.xsd


6. Security 테스트가 필요한 URI 설계
- /index.do 	> 인증(o), 인증(x) > 모든 사용자 접근 가능
- /member.do	> 인증(o) > 인증받은 사용자(회원)만 접근 가능
- /admin.do		> 인증(o) > 인증받은 사용자 중 관리자 권한이 있는 사용자만 접근 가능


7. 파일 추가
- com.test.security.controller > TestController.java
- views > index.jsp
		> member.jsp
		> admin.jsp
- views > inc > header.jsp

8. Security 구성 요소
- 인증(Authentication), 허가 (Authorization)

- AuthenticationManager
	- 인증 매니저
	- 중심 역할
	- 인증을 담당한다.
	- AuthenticationManager <- ProviderManager <-> AuthenticationProvider

- AuthenticationProvider
	- 인증 제공자
	- 실제로 인증 작업을 진행

- UserDetailsService
	- 사용자 정보 + 사용자 권한 > 관리
	- AuthenticationManager <- ProviderManager <-> AuthenticationProvider <-> UserDetailsService 
	
9. 로그인, 로그아웃 + 인증
- security-context.xml 수정

<security:http>
	<security:intercept-url pattern="/index.do" access="permitAll" />
	<security:intercept-url pattern="/member.do" access="hasRole('ROLE_MEMBER')" />
	<security:form-login/>
</security:http>

- pattern : 접근하려는 URI
- access: 허가 처리

- 실행
	- index.do
	- member.do


10. 단순한 로그인 처리
- /security/login 자동 생성 로그인 페이지 사용
- 계정 > XML 정의(security-context.xml) > 인 메모리 방식 > 운영(x), 테스트용(o)
- security-context.xml 수정
	
- <security:user name="hong" password="1111"

*** 스프링 시큐리티에서는 username의 의미 > name > id 역할
- 일반 시스템(userid) == 스프링 시큐리티(username)
- <security:user name="hong" password="1111"

- 실행
- /member.do 로그인 시도
- 오류 발생 > There is no PasswordEncoder mapped for the id "null"
- 스프링 시큐리티 4까지 PasswordEncoder 선택사항
- 스프링 시큐리티 5까지 PasswordEncoder 필수사항
- 우선 테스트를 위해서 임시로 PasswordEncoder 무시하게 설정 >  password="{noop}1111"


- 로그아웃
	- 개발자 도구 > application > cookies > jsessionId > 삭제
	

11. 관리자 추가 
- security-context.xml
- 관리자 계정 추가
- <security:user name="admin" password="{noop}1111" authorities="ROLE_ADMIN"/>

- 관리자 허가 설정
- <security:intercept-url pattern="/admin.do" access="hasRole('ROLE_ADMIN')" />

- 관리자가 member.do 접근 불가


12. 접근 권한 페이지 처리
- 로그인을 안한 상태에서 접근 불가능한 URI 접근 > 로그인 페이지로 이동 
- 로그인을 한 상태에서 접근 불가능한 URI 접근 > 에러 발생(403)

12.1 access-denied-handler URI 지정
or
12.2 AccessDeniedHandler를 직접 구현

- 접근 권한 페이지 추가
	- com.test.security.controller > AuthController.java
	- views > auth > accesserror.jsp


- 위의 URI를 403 오류와 연결하기
	- security-context.xml 수정 


실행
12.3  
- com.test.security.auth > CustomAccessDeniedHandler.java


13. 커스텀 로그인 페이지
- 접근 제한 페이지처럼 로그인 페이지의 URI을 지정할 수 있다.

- AuthController.java > URI 추가
- views > auth > customLogin.jsp

- <input name="username" >,<input name="password"> : name 속성이 예약어 (바꾸면 안됨)
- <form method="POST" action="/security/login"> : POST + URI(예악)

- security-context.xml > 커스텀 로그인 페이지 연결

- 실행 > 로그인 실패
- 실패 이유 > CSRF

CSRF, Cross-site request forgery
- <security:csrf disabled="true" /> -> 개발할때는 꺼도 됨


- customlogin.jsp > CSRF 토큰 추가


14. 로그인 성공 > 후속 동작 처리
- 로그인을 성공한 후 특정한 동작을 하고 싶을 때 > Handler 구현 
- com.test.security.auth > CustomLoginSuccessHandler.java
- security-context.xml > 커스텀 헨들러 연결


15. 로그아웃
- 로그인("/login")의 예약된 URI 처럼 > 로그아웃도 이미 구현된 예약 URI가 있다. > "/logout"
- 커스텀 핸들러 구현 
- AuthController.java > URI 추가
- views > auth >customlogout.jsp
- security-context.xml > 설정 추가


16. 계정 정보
- InMemoryUserDetailsManager 방식
	- <security:user name="hong" password="{noop}1111" authorities="ROLE_MEMBER"/>

- JDBC
	- 미리 정해진 구조의 스키마 사용 > 편함 + 제약 발생
	- 사용자가 직접 만든 구조의 스키마 사용 > 직접 구현 
	
- SecurityTest > script.sql 


17. 미리 정해진 구조의 스키마 사용
- script.sql > 테이블 생성 + 계정 생성
- security-context.xml > JDBC 기반의 인증 작업 설정
- 실행 > There is no PasswordEncoder mapped for the id "null"

18. PasswordEncoder 문제 해결
- 스프링 시큐리티 5부터 PasswordEncoder 사용이 필수
- 위의 상황은 임시로 {noop}을 붙여서 이 문제를 잠시 무시
- 데이터베이스를 사용하려면 반드시 PasswordEncoder를 사용해야 한다. 
- PasswordEncoder > 암호화 작업 

- com.test.security.auth > CustomNoOpPasswordEncoder.java

- security-context.xml > CustomNoOpPasswordEncoder 연결 



19. 사용자가 직접 만든 구조의 스키마 사용
-- script.sql 


20. 사용자 계정 생성하기
- member + member_auth > 계정 추가

- src/test/java > com.test.security > MemberTest.java

- security-context.xml > BCryptPasswordEncoder 사용

-users-by-username-query="" 
-authorities-by-username-query=""


21. 회원가입
- com.test.security.controller > MemberController.java
- com.test.security.mapper > MemberMapper.java(I)
- com.test.security.dto > MemberDTO.java
						> AuthDTO.java
- src/main/resources > com > test > security > mapper > MemberMapper.xml

- views > member > register.jsp


22. UserDetailsService > 커스텀
- 기존 객체 > username, password, enable, authority
- 추가로 회원 정보를 더 관리 > 직접 UserDetailsService 구현 

- com.test.security.auth > CustomUserDetailsService.java
- com.test.security.dto > CustomUser.java
- views > member > info.jsp

- security-context.xml > 적용


















